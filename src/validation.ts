/** Contains the validation types. */
import * as validator from 'validator';
import * as _ from 'lodash';

import { Model, ModelConstructor } from './model';

/** An error with a single property of a model. */
export interface PropertyError {
  /**
   * The type of error. This is used to specify what particular validation
   * raised the property error. This is the best thing to use for generating
   * the user-appropriate error message for a property error message
   * generated by a validation, which may not be particularly user-friendly on its own.
   */
  type: string;

  /** The error message generated by a validation. */
  message: string;
}

/**
 * Errors with the properties of a model. Each model property can have
 * an array of errors.
 */
export type ModelErrors<T extends Model> = {
  [P in keyof T]?: PropertyError;
};

/**
 * Errors common to a subset of a model's properties or the whole model.
 *
 * The suggested usage for this would be for when there's an error that affects
 * multiple properties, such as when there's a shared unique key failure.
 * It's also useful for providing errors that are general to the entire model instance,
 * such as when there's some business logic error.
 */
export interface CommonModelError {
  /**
   * The type of the common error.
   *
   * @see PropertyError
   */
  type: string;

  /**
   * Properties referenced by the common error, e.g. which
   * properties triggered a specific error case.
   */
  props?: string[];

  /** The common error message, either for the joint properties or for the entire model. */
  message: string;
}

/**
 * An error raised when a model instance fails to validate.
 *
 * This has a mapped errors object so that you access the errors by a specific model property.
 */
export class ValidationError<T extends Model> extends Error {
  /** The model constructor. */
  ctor: ModelConstructor<T>;

  /** The model errors. */
  errors?: ModelErrors<T>;

  /** The model errors that are common across the entire model or multiple properties. */
  commonErrors?: CommonModelError[];

  /**
   * Construct a validation error.
   *
   * @param ctor The model constructor this error is for.
   * @param message The error message.
   * @param errors The model errors with all of the validation errors on it.
   * @param commonErrors Any common errors for a subset of the properties or the whole model.
   */
  constructor(ctor: ModelConstructor<T>, message: string,
              errors?: ModelErrors<T>, commonErrors?: CommonModelError[]) {
    super(message);

    this.name = 'ValidationError';
    this.stack = new Error().stack;
    this.ctor = ctor;
    this.errors = errors;
    this.commonErrors = commonErrors;

    // Required in order for error instances to be able to use instanceof.
    // SEE: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md
    (this as any).__proto__ = ValidationError.prototype;
  }
}

/**
 * An error raised during validation of a model's property.
 * This should be rejected with by a `ValidationFunction`.
 *
 * @see ValidationFunction
 */
export class PropertyValidationError extends Error {
  /**
   * The validation error type.
   *
   * @see PropertyError
   */
  type: string;

  /**
   * Construct a property validation error.
   *
   * @param type The validation error type.
   * @param message The error message.
   */
  constructor(type: string, message: string) {
    super(message);

    this.name = 'PropertyValidationError';
    this.stack = new Error().stack;
    this.type = type;

    // Required in order for error instances to be able to use instanceof.
    // SEE: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md
    (this as any).__proto__ = PropertyValidationError.prototype;
  }
}

/**
 * A validation function that can be used to validate a model property and its value.
 *
 * The function should return a promise that resolves when validation is successful,
 * or rejects with a `PropertyValidationError` if the property validation failed.
 *
 * Any errors rejected other than `PropertyValidationError` (i.e. if there's some unknown
 * fatal error) will be coerced into a `PropertyValidationError` with its type marked
 * as 'unknown'.
 */
export type ValidationFunction = (path: string, value: any, options?: any) => Promise<void>;

/** A validation to be run on a model's property. */
export interface Validation {
  /** The function for validating the property. */
  cb: ValidationFunction;

  /** Any extra options to provided to the validation function. */
  options?: any;
}

/** Validates that an attribute is an email. */
export async function IS_EMAIL(_path: string, value: any): Promise<void> {
  if (!validator.isEmail(_.toString(value))) {
    throw new PropertyValidationError('attribute.email', 'Not an email');
  }
}

/** Validates that an attribute is a URL. */
export async function IS_URL(_path: string, value: any): Promise<void> {
  if (!validator.isURL(_.toString(value))) {
    throw new PropertyValidationError('attribute.url', 'Not a URL');
  }
}

/** Validates that an attribute is a UUID (v3, v4 or v5). */
export async function IS_UUID(_path: string, value: any): Promise<void> {
  if (!validator.isUUID(_.toString(value))) {
    throw new PropertyValidationError('attribute.uuid', 'Not a UUID');
  }
}

/** Validates that an attribute is a valid JSON string. */
export async function IS_JSON(_path: string, value: any): Promise<void> {
  if (!validator.isJSON(_.toString(value))) {
    throw new PropertyValidationError('attribute.json', 'Not valid JSON');
  }
}

/** Validates that an attribute is a hexadecimal string. */
export async function IS_HEX(_path: string, value: any): Promise<void> {
  if (!validator.isHexadecimal(_.toString(value))) {
    throw new PropertyValidationError('attribute.hex', 'Not hexadecimal');
  }
}

/** Validates that an attribute is an alphabetic-only string. */
export async function IS_ALPHA(_path: string, value: any): Promise<void> {
  if (!validator.isAlpha(_.toString(value))) {
    throw new PropertyValidationError('attribute.alpha', 'Not alphabetical');
  }
}

/** Validates that an attribute is an alphanumeric-only string. */
export async function IS_ALPHANUMERIC(_path: string, value: any): Promise<void> {
  if (!validator.isAlphanumeric(_.toString(value))) {
    throw new PropertyValidationError('attribute.alphanumeric', 'Not alphanumerical');
  }
}

/** Validates that an attribute is a valid BASE64 string. */
export async function IS_BASE64(_path: string, value: any): Promise<void> {
  if (!validator.isBase64(_.toString(value))) {
    throw new PropertyValidationError('attribute.base64', 'Not valid base64');
  }
}

/** Validates that an attribute is an uppercase string. */
export async function IS_UPPERCASE(_path: string, value: any): Promise<void> {
  if (!validator.isUppercase(_.toString(value))) {
    throw new PropertyValidationError('attribute.uppercase', 'Not uppercase text');
  }
}

/** Validates that an attribute is a lowercase string. */
export async function IS_LOWERCASE(_path: string, value: any): Promise<void> {
  if (!validator.isLowercase(_.toString(value))) {
    throw new PropertyValidationError('attribute.lowercase', 'Not lowercase text');
  }
}

/** Validates that an attribute is an IP address. */
export async function IS_IP(_path: string, value: any): Promise<void> {
  if (!validator.isIP(_.toString(value))) {
    throw new PropertyValidationError('attribute.ip', 'Not an IP address');
  }
}

/** Validates that an attribute matches a regex. */
export function MATCHES(regex: RegExp): ValidationFunction {
  return async (_path: string, value: any): Promise<void> => {
    if (!validator.matches(_.toString(value), regex)) {
      throw new PropertyValidationError('attribute.matches', 'No match for ' + regex.toString());
    }
  };
}

/** Validates that an attribute is greater than a specific number. */
export function GT(other: number): ValidationFunction {
  return async (_path: string, value: any): Promise<void> => {
    if (_.isNumber(value) && !(value > other)) {
      throw new PropertyValidationError('attribute.gt', 'Not greater than ' + other);
    }
  };
}

/** Validates that an attribute is less than a specific number. */
export function LT(other: number): ValidationFunction {
  return async (_path: string, value: any): Promise<void> => {
    if (_.isNumber(value) && !(value < other)) {
      throw new PropertyValidationError('attribute.lt', 'Not less than ' + other);
    }
  };
}

/** Validates that an attribute is less than or equal to a specific number. */
export function GTE(other: number): ValidationFunction {
  return async (_path: string, value: any): Promise<void> => {
    if (_.isNumber(value) && !(value >= other)) {
      throw new PropertyValidationError('attribute.gte', 'Not greater than or equal to ' + other);
    }
  };
}

/** Validates that an attribute is less than or equal to a specific number. */
export function LTE(other: number): ValidationFunction {
  return async (_path: string, value: any): Promise<void> => {
    if (_.isNumber(value) && !(value <= other)) {
      throw new PropertyValidationError('attribute.lte', 'Not less than or equal to ' + other);
    }
  };
}

/** Validates that an attribute has a specific array or string length. */
export function LENGTH(length: number): ValidationFunction {
  return async (_path: string, value: any): Promise<void> => {
    if ((_.isArray(value) || _.isString(value)) && value.length !== length) {
      throw new PropertyValidationError('attribute.length', 'Not of length ' + length);
    }
  };
}

/** Validates that an attribute has a specific array or string length at minimum. */
export function MIN_LENGTH(length: number): ValidationFunction {
  return async (_path: string, value: any): Promise<void> => {
    if ((_.isArray(value) || _.isString(value)) && value.length < length) {
      throw new PropertyValidationError('attribute.minLength', 'Not of minimum length ' + length);
    }
  };
}

/** Validates that an attribute has a specific array or string length at maximum. */
export function MAX_LENGTH(length: number): ValidationFunction {
  return async (_path: string, value: any): Promise<void> => {
    if ((_.isArray(value) || _.isString(value)) && value.length > length) {
      throw new PropertyValidationError('attribute.maxLength', 'Not of maximum length ' + length);
    }
  };
}
